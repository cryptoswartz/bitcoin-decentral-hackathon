if 0:
    return(100)
else:
    if !contract.storage[1000]:  // initialize contract by storing locations of other contracts
        contract.storage[1000] = 1
        contract.storage[1001] = msg.data[0]
        contract.storage[1002] = msg.data[1]
        contract.storage[1003] = msg.data[2]
        return(contract.storage[1001])
    else:
        if msg.data[0] == 1: // publish
            if !(msg.datasize == 2):
                return(0)
            frm = msg.sender
            to = contract.storage[1001]
            root = msg.data[1]
            data = array(2)
            data[0] = root
            data[1] = frm
            out = msg(to,0,tx.gas-1000,data,2)
            return(out)
        elif msg.data[0] == 2: //tag
            if !(msg.datasize == 3):
                return(0)
            root = msg.data[1]
            to = contract.storage[1001]
            dataexists = msg(to,0,tx.gas-100,[root],1) 
            if dataexists == 0:
                stop
            else:
                tag = msg.data[2]
                to = contract.storage[1002]
                out = msg(to,0,tx.gas-100,[root, tag, 0],3)
            return(2)
        elif msg.data[0] == 3: //vote
                if !(msg.datasize == 4):
                    return(0)
                root = msg.data[1]
                tag = msg.data[2]
                vote = msg.data[3]
                to = contract.storage[1001]
                dataexists = msg(to,0,tx.gas-100,[root],1) 
                if dataexists == 0:
                    stop
                else:
                    to = contract.storage[1002]
                    ntags = contract.storage[root + 1]
                    tagnum = msg(to,0,tx.gas-100,[root, tag, 1],2)
                    if tagnum == 0:
                        stop
                    else:
                        to = contract.storage[1003]
                        msg(to,0,tx.gas-100,[root,tagnum,vote,0],3)
                    return(3)

